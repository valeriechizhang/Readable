import React from 'react';
import PropTypes from 'prop-types';
import * as ReactRedux from 'react-redux';
import { createAction } from 'redux-actions';
import * as Redux from 'redux';
import Immutable from 'immutable';
import axios from 'axios';
import { isEqual } from 'lodash-es';
import JSONTree from 'react-json-tree';

class Data extends React.Component {
  constructor(props) {
    super(props);
    this.fetch = this.fetch.bind(this);
  }

  componentWillMount() {
    // We should fetch data on mount
    this.fetch(this.props);

    if (this.props.refreshInterval) {
      this.interval = setInterval(() => this.fetch(this.props), this.props.refreshInterval);
    }
  }

  componentWillReceiveProps(nextProps) {
    if (!isEqual(nextProps.keyPath, this.props.keyPath)) {
      if (!nextProps.persist) {
        this.props.dataClear({ keyPath: this.props.keyPath });
      }
      this.fetch(nextProps);
    } else if (nextProps.url !== this.props.url || !isEqual(nextProps.config, this.props.config)) {
      this.fetch(nextProps);
    }

    if (nextProps.refreshInterval !== this.props.refreshInterval) {
      clearInterval(this.interval);
      if (nextProps.refreshInterval) {
        this.interval = setInterval(() => this.fetch(), nextProps.refreshInterval);
      }
    }
  }

  componentWillUnmount() {
    if (!this.props.persist) {
      this.props.dataClear({ keyPath: this.props.keyPath });
    }
  }

  fetch(props = this.props) {
    props.dataRequest({ keyPath: props.keyPath });

    axios(props.url, props.config)
      .then((response) => {
        if (response.status < 400) {
          props.dataResponse({
            keyPath: props.keyPath,
            response: props.transformResponse(response, props.data),
          });
        } else {
          props.dataError({
            keyPath: props.keyPath,
            response: {
              ...response,
            },
          });
        }
      })
      .catch(() => props.dataError({ keyPath: props.keyPath }));
  }

  render() {
    const { children, debug, data } = this.props;

    // Debug mode
    if (debug) {
      return <JSONTree data={data} />;
    }

    return children;
  }
}

Data.propTypes = {
  url: PropTypes.string.isRequired,
  keyPath: PropTypes.arrayOf(PropTypes.string).isRequired,

  config: PropTypes.object,
  debug: PropTypes.bool,
  persist: PropTypes.bool,
  refreshInterval: PropTypes.number,
  transformResponse: PropTypes.func,

  reduxRoot: PropTypes.string,
  requestAction: PropTypes.string,
  responseAction: PropTypes.string,
  errorAction: PropTypes.string,
  clearAction: PropTypes.string,

  children: PropTypes.node,
  // From container
  data: PropTypes.object,
  dataRequest: PropTypes.func,
  dataResponse: PropTypes.func,
  dataError: PropTypes.func,
  dataClear: PropTypes.func,
};

Data.defaultProps = {
  config: null,
  debug: false,
  refreshOnMount: false,
  persist: false,
  refreshInterval: null,
  transformResponse: a => a,

  reduxRoot: 'data',
  requestAction: 'DATA_REQUEST',
  responseAction: 'DATA_RESPONSE',
  errorAction: 'DATA_ERROR',
  clearAction: 'DATA_CLEAR',

  children: null,
  data: null,
  dataRequest: () => {},
  dataResponse: () => {},
  dataError: () => {},
  dataClear: () => {},
};

const mapStateToProps = (state, ownProps) => ({
  data: state[ownProps.reduxRoot || 'data'].getIn(ownProps.keyPath, new Immutable.Map()),
});

const mapDispatchToProps = (dispatch, ownProps) => ({
  dataRequest: Redux.bindActionCreators(
    createAction(ownProps.requestAction || 'DATA_REQUEST'),
    dispatch,
  ),
  dataResponse: Redux.bindActionCreators(
    createAction(ownProps.responseAction || 'DATA_RESPONSE'),
    dispatch,
  ),
  dataError: Redux.bindActionCreators(createAction(ownProps.errorAction || 'DATA_ERROR'), dispatch),
  dataClear: Redux.bindActionCreators(createAction(ownProps.clearAction || 'DATA_CLEAR'), dispatch),
});

export default ReactRedux.connect(mapStateToProps, mapDispatchToProps)(Data);
