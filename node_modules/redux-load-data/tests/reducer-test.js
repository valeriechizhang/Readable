import expect from 'expect';
import { createAction } from 'redux-actions';
// import sinon from 'sinon';
import Immutable from 'immutable';
import { dataReducer } from '../src/';

const dataRequest = createAction('DATA_REQUEST');
const dataResponse = createAction('DATA_RESPONSE');
const dataError = createAction('DATA_ERROR');
const dataClear = createAction('DATA_CLEAR');

describe('Reducer', () => {
  let reducer;

  beforeEach(() => {
    reducer = dataReducer();
  });

  it('should initialise to empty map', () => {
    expect(reducer(undefined, {})).toEqual(new Immutable.Map());
  });

  it('should handle DATA_REQUEST', () => {
    const afterRequest = reducer(new Immutable.Map(), dataRequest({ keyPath: ['test'] }));
    expect(afterRequest.getIn(['test', 'error'])).toEqual(false);
    expect(afterRequest.getIn(['test', 'loading'])).toEqual(true);
  });

  it('should handle DATA_RESPONSE', () => {
    const afterRequest = reducer(
      new Immutable.Map(),
      dataResponse({ keyPath: ['test'], response: { data: { test: true } } }),
    );
    expect(afterRequest.getIn(['test', 'error'])).toEqual(false);
    expect(afterRequest.getIn(['test', 'loading'])).toEqual(false);
    expect(afterRequest.getIn(['test', 'data']).toJS()).toEqual({ test: true });
  });

  it('should handle DATA_ERROR', () => {
    const afterRequest = reducer(new Immutable.Map(), dataError({ keyPath: ['test'] }));
    expect(afterRequest.getIn(['test', 'error'])).toEqual(true);
    expect(afterRequest.getIn(['test', 'loading'])).toEqual(false);
  });

  it('should handle DATA_CLEAR', () => {
    const afterRequest = reducer(
      new Immutable.Map({ test: { ready: true, error: true } }),
      dataClear({ keyPath: ['test'] }),
    );
    expect(afterRequest.getIn(['test'])).toEqual(undefined);
  });
});
